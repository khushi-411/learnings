# Representing and Manipulating Information

- Binary values work better when building machines that store and process information.
- Two-value signal (binary digits or bits) are readily represented, transmitted, and stored.
- Using standard character code we encode the letters and symbols in a document.
- This chapter covers this encoding and encoding for negative numbers and to approximate real numbers.
- Encodings are Unsigned encodings, Signed integers encodings, and Floating-point encodings.
- Computer representations use a limited number of bits to encode a number, hence sometimes operations overflow.
- Integer computer arithmetic satisfies many properties of the true integer arithmetic.
- Floating-point number does not necessary statisfy it, like overflow will yield `+âˆž`, it's not associative.
- Floating-point has wide range, unlike integer, but are just approximate, unlike integer who are accurate.
- How to perform arithmetic operations by directly manipulating bit-level representations of numbers?
    - Requires understanding of mahine-level code generated by compilers in attempt to optimize the performance.

### Information Storage
- **Virtual Memory**: a machine-level program views memory as a very large array of bytes.
- Smallest addressable unit of memory: $8$ bits or *bytes*.
    - Every byte of memory is identified as a unique number known as **address**.
    - The set of all possible addresses is known as the **virtual address space**.
    - It is a conceptual image presented to the machine-level program.
- What appears to be a monolithic byte array?
- How compiler and run-time systems partitions the memory space into more manageable units to store th different program objects?
- What are the mechanisms used to store and manage different parts of the program?
- For example, a pointer pointing to some space, it is actually a virtual address.
- The actual machine level program generates no information about data types.
- Pointers in C!! more details in the next chapter.

#### Hexadecimal Notation
- Binary notation of bits range: $00000000_2$ to $11111111_2$.
- When viewed as a decimal integer range: $0_{10}$ to $255_{10}$.
- None of these is convenient for describing bit patterns, but we write it as base-16 or ***hexadecimal*** numbers.
- It uses digits $0$ to $9$ along with characters $A$ through $F$ to represent $16$ possible values.
- A single byte can range from $00_{16}$ to $FF_{16}$.
- In C, numeric constants start with $0x$ or $0X$.
- Characters $F$ and $A$ can be writen in both uppercase and lowercase).
- *Practice Task*: Converting decimal, binary, and hexadecimal representations of bit patters.

<div align="center">

| Hex Digit | Decimal Value | Binary Value                            |
|:-----------:|:---------------:|:-----------------------------------------:|
| 0         | 0             | 0000                                    |
| 1         | 1             | 0001                                    |
| 2         | 2             | 0010                                    |
| 3         | 3             | 0011                                    |
| 4         | 4             | 0100                                    |
| 5         | 5             | 0101                                    |
| 6         | 6             | 0110                                    |
| 7         | 7             | 0111                                    |
| 8         | 8             | 1000                                    |
| 9         | 9             | 1001                                    |
| A         | 10            | 1010                                    |
| B         | 11            | 1011                                    |
| C         | 12            | 1100                                    |
| D         | 13            | 1101                                    |
| E         | 14            | 1110                                    |
| F         | 15            | 1111                                    |

</div>

- For example, convert this number $0x173A4C$ to binary format:
    - This can be done by expanding each term to hexadecimal format.
- We'll get a binary representation.
- To convert this binary representation, we can split into groups of $4$ bits each and follow the table.

| Hexadecimal |  1   |  7   |  3   |  A   |  4   |  C   |
| ------------|------|------|------|------|------|------|
| Binary      | 0001 | 0111 | 0011 | 1010 | 0100 | 1100 |

- When $x$ is a power of $2$, $x = 2_n$, $n$ can be written in the form of $i + 4j$.
- Example: $x = 2048 = 2^{11}$, will have $n = 11 = 3 + 4 . 2$, and its hexadecimal representation is given by $0x800$.

- To convert decimal number to hexadecimal number: repeatedly divide by $16$ as follows, here decimal is $ 314,156$:
    - Hexadecimal representaion is $0x4CB2C$.

$$
314,156 = 19,634 . 16 + 12   (C)
$$

$$
19,634 = 1,227 . 16 + 2      (2)
$$

$$
1,227 = 76 . 16 + 11         (B)
$$

$$
76 = 4 . 16 + 12             (C)
$$

$$
4 = 0 . 16 + 4               (4)
$$

- Conversly, to convert hexadecimal to decimal we multiple each term by $16$ with proper power.
- For example, for number $0x7AF$:

$$
7 . 16^2 + 10 . 16 + 15 = 7 . 256 + 10 . 16 + 15 = 1,792 + 160 + 15 = 1,967.
$$

#### Data Sizes
- Every computer has ***word size***, which is a nominal size of pointer data.
- A machine with a $w$ bit word size, the virtual address can range from $0$ to $2^w - 1$.
    - Program can access to at most $2^w$ bytes.
- In recent years there has been a wide shift with $32$ bits machine to a $64$ bits machine.
    - $32$ bit machine: $4$ GB virtual address space, i.e., $4 x 10^9$ bytes.
    - $64$ bit machine: $16$ exabytes, i.e., $1.84 . 10^{19}$ bytes.
- A $64$ bit machine can also run program designed for a $32$ bit machine for backward compatibility.
- Each computer and compilers can have different data formats of data types as designed by engineers. Here's how C has:

<div align="center">

| C Declaration | Signed/Unsigned | 32-bit | 64-bit |
|---------------|-----------------|:--------:|:--------:|
| char          | signed          | 1      | 1      |
| unsigned char | unsigned        | 1      | 1      |
| short         | signed          | 2      | 2      |
| unsigned short| unsigned        | 2      | 2      |
| int           | signed          | 4      | 4      |
| unsigned      | unsigned        | 4      | 4      |
| long          | signed          | 4      | 8      |
| unsigned long | unsigned        | 4      | 8      |
| int32_t       | signed          | 4      | 4      |
| uint32_t      | unsigned        | 4      | 4      |
| int64_t       | signed          | 8      | 8      |
| uint64_t      | unsigned        | 8      | 8      |
| char *        |                | 4      | 8      |
| float         |                | 4      | 4      |
| double        |                | 8      | 8      |

</div>

- To avoid this difference ISO C99 introduced a class of data types where the data size are fixed regardless of any computer and compilers.
- Note that, most of the compilers and computer declare *char* as signed data type. But C does not gureentee this.
- The C standard has lower bound for each data type but there is no upper bound.

#### Addressing and Byte Ordering
